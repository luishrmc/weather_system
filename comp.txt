### ðŸ“‹ MASTER PROMPT â€“ CODE COMPARISON (WEATHER STATION BACKEND)

**Task**
Critically compare **Code_A** (version previously proposed by the AI) with **Code_B** (userâ€™s current version provided at the end of the prompt) and produce a **final optimized version of the analyzed module**, ensuring full alignment with the architecture of the **weather station** project:

* ESP32 â†’ MQTT (Mosquitto) â†’ `mqtt_client.py` â†’ `influx_client.py` â†’ InfluxDB 3 Core â†’ PyQt6 GUI (`ui/main_windown.py`)
* Runs in container / devcontainer, with `requirements.txt` and environment-based configuration.

The analysis should consider complete **Python modules** (`.py`), including:

* `mqtt_client.py` (signatures, callbacks, JSON parsing, broker connection)
* `influx_client.py` (InfluxDB 3 client, writes and queries)
* `main.py` (orchestration, wiring between MQTT, Influx, and GUI)
* Optional helper modules (`config.py`, data models, etc.), when provided.

---

### Inputs

* **Code_A**: AI proposal (Python module(s), or relevant excerpts).
* **Code_B**: userâ€™s current code.
* **Context**: which module is being evaluated:

  * `mqtt_client.py`,
  * `influx_client.py`,
  * `main.py`,
  * configuration module,
  * data model (e.g., `WeatherSample`) or other backend component.
* **Relevant specifications of the weather station project** (treat as reference requirements):

  * Backend in **Python 3.10+**, with:

    * `paho-mqtt` for the MQTT client.
    * Official or appropriate client for **InfluxDB 3 Core**.
    * **PyQt6** in `ui/main_windown.py` (future or existing integration).
  * `mqtt_client.py` must:

    * Connect to the Mosquitto broker configured under `config/mosquitto`.
    * Subscribe to defined topics (e.g., `weather/#`).
    * Read **JSON** payloads sent by the ESP32.
    * Validate and normalize data (timestamp, units, types).
    * Wrap each sample into a clear structure (e.g., `WeatherSample`) and forward it to the rest of the system (Influx / GUI).
  * `influx_client.py` must:

    * Manage connection to InfluxDB 3 Core (host, port, token, org, database/bucket).
    * Write measurements consistently (measurement name, tags, fields).
    * Expose common queries for the GUI (last N samples, time window, simple aggregations).
  * `main.py` must:

    * Load configuration (env vars or `config` module).
    * Instantiate `InfluxClient` and `MQTTClient`.
    * Wire callbacks so MQTT messages are persisted in InfluxDB.
    * Prepare (or integrate) the PyQt6 GUI event loop in a way that respects Qtâ€™s event loop.
  * **Minimal and modular implementation**:

    * Clear separation of responsibilities (communication, persistence, orchestration).
    * Use of **type hints**, **docstrings**, and **logging** instead of `print()` for logs.
    * No unnecessary â€œmagicâ€: avoid excessive global state, hidden side effects, and overengineering.
  * Configuration via **environment variables** or a dedicated module:

    * E.g. `MQTT_HOST`, `MQTT_PORT`, `MQTT_USERNAME`, `MQTT_PASSWORD`,
      `INFLUX_HOST`, `INFLUX_PORT`, `INFLUX_TOKEN`, `INFLUX_ORG`, `INFLUX_DATABASE`.

---

### Objective

Produce a **final, high-quality version** of the code that is correct, modular, and coherent with the weather station architecture, minimizing redundancy, fixing spec violations, and ensuring:

* robust MQTT communication (reconnect, callbacks, error handling);
* consistent, queryable storage in InfluxDB 3;
* clear organization between modules (`mqtt_client.py`, `influx_client.py`, `main.py`, etc.);
* configurability via environment / config, with no hardcoded secrets;
* a solid foundation for PyQt6 GUI integration;
* clear, readable, and maintainable code.

---

### Comparison Criteria

Evaluate **Code_A** and **Code_B** according to:

1. **Adherence to the project architecture**

   * Correct data flow: MQTT â†’ parsing â†’ domain object â†’ InfluxDB â†’ GUI.
   * Appropriate use of callbacks, events, or queues to decouple modules.
   * Alignment with container / devcontainer usage (no machine-specific hardcoded paths).

2. **Technical correctness**

   * Coherent function signatures (types, parameters, return values).
   * Proper usage of **type hints** and `dataclasses` (when applicable).
   * Exception handling (MQTT/Influx connections, JSON parsing, timeouts).
   * Resource management: connections opened/closed correctly, reconnection strategies, etc.

3. **Modularity and organization**

   * Proper separation between modules (`mqtt_client.py`, `influx_client.py`, `main.py`).
   * No circular dependencies or unnecessary coupling.
   * Clear class and function structure (well-defined responsibilities).

4. **Consistency between modules**

   * `MQTTClient` API compatible with what `main.py` expects.
   * `InfluxClient` API compatible with `main.py` and, later, with the GUI.
   * Data model (`WeatherSample` or similar) consistent across the codebase.

5. **Locality, efficiency, and robustness**

   * Efficient and clear JSON parsing.
   * Reasonable write/query patterns for Influx (no unnecessary overhead).
   * Proper logging usage (levels, informative messages) for debugging and operation.

6. **Conformance to Python best practices**

   * PEP 8, clear names for variables and functions.
   * Avoiding unnecessary global state, hidden side effects, and dead code.
   * Test-friendly structure where possible (functions / classes easy to test).

7. **Style and minimalism**

   * No methods beyond what is needed for the defined data flow.
   * Avoid complex abstractions that donâ€™t add value to the current project.

---

### Required Output (Standard Structure)

**1. Key differences (A vs B)**
Clearly list, in short bullets:

* what **Code_A** implements that **Code_B** does not;
* what **Code_B** does better than **Code_A**;
* structural differences (classes vs functions, module organization, use of dataclasses);
* responsibility differences (who opens connections, who formats Influx points, who validates JSON);
* differences in architectural alignment (MQTT â†’ Influx â†’ GUI).

---

**2. Strengths**

**2.1) Code_A:** objective bullets, e.g.:

* â€œgood separation between parsing and database writingâ€
* â€œconsistent use of type hintsâ€
* â€œautomatic MQTT reconnection implementedâ€, etc.

**2.2) Code_B:** objective bullets, e.g.:

* â€œbetter adherence to project variable namesâ€
* â€œintegration with GUI already wiredâ€, etc.

---

**3. Weaknesses**

**3.1) Code_A:** objective bullets.
**3.2) Code_B:** objective bullets.

Focus on:

* bug risks;
* architectural or best-practice violations;
* unnecessary coupling;
* missing error handling;
* missing logging, etc.

---

**4. Recommended actions**

Each bullet must **start with a verb**, for example:

* â€œkeep the `MQTTClient` class structure from Aâ€
* â€œremove loose print statements and replace with loggingâ€
* â€œfix JSON parsing to validate required fieldsâ€
* â€œcondense connection logic into a single MQTT setup methodâ€
* â€œexpand Influx client to support time-window queriesâ€
* â€œstandardize field names (`temperature_c`, `humidity_pct`, etc.)â€
* â€œalign `WeatherSample` format between MQTT and Influx layersâ€
* â€œextract configuration into environment variablesâ€
* â€œadjust encapsulation to avoid global variablesâ€.

Short, objective sentences, **one per line**.

---

**5. Suggested final version of the code**

**5.1) Final mode selection (one line)**
Indicate:

* â€œOnly Aâ€, or
* â€œOnly Bâ€, or
* â€œCombination A+Bâ€

and justify in **one line** (e.g., â€œCombination A+B, keeping Aâ€™s modular structure and Bâ€™s already-tested config flowâ€).

**5.2) Final Consolidated Code**
Provide the complete code for the relevant module(s), ready to paste:

* standardized naming;
* minimalism (only what is needed for the MQTT â†’ Influx â†’ GUI flow);
* compatibility with other project modules;
* consistent use of type hints, docstrings, and logging;
* clear separation of responsibilities;
* explicit dependency on configuration (env vars or `config` module);
* essential comments only (for important design decisions, not obvious behavior).

---

**6. Traceability notes**

List:

* Which decisions are based on which parts of the **weather station architecture** (e.g., need to parse ESP32 JSON, data flow into InfluxDB, GUI consumption).
* Which choices are driven by Python best practices (PEP 8, logging, type hints).
* Whenever a piece of information is missing (e.g., exact JSON shape from the ESP32, MQTT topic names, Influx schema), explicitly mark: **â€œreference neededâ€**.

---

**7. Size optimization**

* Estimate whether the final code increases or decreases line count compared to A and B.
* Mark which parts are **condensable** (can be simplified) without loss of functionality or clarity.
* Indicate where it is worth splitting into helper functions for readability.

---

**8. Operation rules**

* Evaluate **only the provided code**, do not rewrite the entire project.
* Maintain compatibility with previously discussed steps of the weather station backend.
* When there is ambiguity in style (for example: class vs free functions), offer **two short options** and choose one, with a one-line justification (e.g., â€œclass improves future reuse, so option 1 is preferredâ€).
* Wait for my confirmation before applying the same pattern to other modules (`mqtt_client.py`, `influx_client.py`, `main.py`, etc.).

CODE:

"""
Weather Station Application - Main Entry Point

Orchestrates the data flow: MQTT â†’ InfluxDB 3 Core.
Subscribes to weather sensor data over MQTT and stores it in InfluxDB.
"""

import logging
import signal
import sys
import time
from typing import Optional

from app.config import config
from app.influx_client import InfluxClient
from app.models import WeatherSample
from app.mqtt_client import MQTTClient


# ---------------------------------------------------------------------------
# Logging configuration
# ---------------------------------------------------------------------------

logging.basicConfig(
    level=getattr(logging, config.log_level.upper(), logging.INFO),
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),
        # Optionally add file handler, e.g.:
        # logging.FileHandler("weather_station.log"),
    ],
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Main Application
# ---------------------------------------------------------------------------

class WeatherStationApp:
    """
    Main application class for the weather station.

    Responsibilities:
    - Initialize and manage MQTT and InfluxDB clients.
    - Receive WeatherSample objects via MQTT callback.
    - Persist samples to InfluxDB.
    - Track and report basic statistics.
    """

    def __init__(self) -> None:
        """Initialize the application but do not connect yet."""
        logger.info("=" * 70)
        logger.info("Weather Station Application Starting")
        logger.info("=" * 70)

        # Display effective configuration
        logger.info("Configuration: %s", config)

        # Statistics tracking
        self.samples_received: int = 0
        self.samples_written: int = 0
        self.samples_failed: int = 0
        self.start_time: float = time.time()

        # Clients (created in setup)
        self.influx_client: Optional[InfluxClient] = None
        self.mqtt_client: Optional[MQTTClient] = None

        # Shutdown flag
        self.shutdown_requested: bool = False

    # ------------------------------------------------------------------ #
    # Setup & lifecycle
    # ------------------------------------------------------------------ #

    def setup(self) -> None:
        """
        Set up connections to InfluxDB and MQTT broker.

        Raises:
            ConnectionError: If either connection fails.
        """
        logger.info("Setting up connections...")

        # 1. Connect to InfluxDB first
        logger.info("Connecting to InfluxDB...")
        self.influx_client = InfluxClient(config.influxdb)
        self.influx_client.connect()

        # Optional: verify database accessibility
        try:
            count = self.influx_client.query_count()
            logger.info("InfluxDB ready. Current record count: %s", count)
        except Exception as exc:  # noqa: BLE001
            logger.warning("Could not query initial count from InfluxDB: %s", exc)

        # 2. Set up MQTT client with callback
        logger.info("Setting up MQTT client...")
        self.mqtt_client = MQTTClient(
            config=config.mqtt,
            on_sample_received=self._on_sample_received,
        )

        # 3. Connect to MQTT broker and start loop
        self.mqtt_client.connect()
        self.mqtt_client.start()

        logger.info("=" * 70)
        logger.info("Setup complete! Waiting for sensor data...")
        logger.info("Subscribed to topic: %s", config.mqtt.topic)
        logger.info("Press Ctrl+C to stop")
        logger.info("=" * 70)

    # ------------------------------------------------------------------ #
    # MQTT callback and stats
    # ------------------------------------------------------------------ #

    def _on_sample_received(self, sample: WeatherSample) -> None:
        """
        Callback invoked when a WeatherSample is received from MQTT.

        Writes the sample to InfluxDB and updates statistics.

        Args:
            sample: Parsed and validated weather sample.
        """
        self.samples_received += 1

        if not self.influx_client:
            # Defensive guard: should never happen if setup() succeeded.
            self.samples_failed += 1
            logger.error("Influx client not initialized; cannot write sample.")
            logger.debug("Orphan sample: %s", sample)
            return

        try:
            self.influx_client.write_sample(sample)
            self.samples_written += 1

            # Log a concise summary of the sample
            logger.info(
                "[%d] %s | T: %.1fÂ°C | H: %.1f%% | CO2: %.0f ppm | Battery: %.2f V",
                self.samples_received,
                sample.timestamp.strftime("%H:%M:%S"),
                sample.temperature_c,
                sample.humidity_pct,
                sample.air_quality_co2_ppm,
                sample.battery_voltage,
            )

            # Periodically show aggregated statistics
            if self.samples_received % 10 == 0:
                self._show_statistics()

        except Exception as exc:  # noqa: BLE001
            self.samples_failed += 1
            logger.error("Failed to write sample to InfluxDB: %s", exc)
            logger.debug("Failed sample: %s", sample)

    def _show_statistics(self) -> None:
        """Display application statistics in the logs."""
        uptime = time.time() - self.start_time
        uptime_str = time.strftime("%H:%M:%S", time.gmtime(uptime))

        success_rate = (
            (self.samples_written / self.samples_received * 100.0)
            if self.samples_received > 0
            else 0.0
        )

        logger.info("-" * 70)
        logger.info("Statistics | Uptime: %s", uptime_str)
        logger.info(
            "  Received: %d | Written: %d | Failed: %d | Success: %.1f%%",
            self.samples_received,
            self.samples_written,
            self.samples_failed,
            success_rate,
        )
        logger.info("-" * 70)

    # ------------------------------------------------------------------ #
    # Main loop and shutdown
    # ------------------------------------------------------------------ #

    def run(self) -> None:
        """
        Main application loop.

        Keeps the application running until shutdown is requested.
        """
        try:
            while not self.shutdown_requested:
                time.sleep(1.0)
                # Optional: periodic health checks could be added here.
        except KeyboardInterrupt:
            logger.info("Keyboard interrupt received")
            self.shutdown_requested = True
        finally:
            self.shutdown()

    def shutdown(self) -> None:
        """Gracefully shut down all connections and display final statistics."""
        if self.shutdown_requested is False:
            # If called directly without flag, mark shutdown
            self.shutdown_requested = True

        logger.info("=" * 70)
        logger.info("Shutting down Weather Station Application")
        logger.info("=" * 70)

        # Show final statistics
        self._show_statistics()

        # Stop MQTT client
        if self.mqtt_client is not None:
            logger.info("Stopping MQTT client...")
            try:
                self.mqtt_client.stop()
            except Exception:  # noqa: BLE001
                logger.exception("Error while stopping MQTT client")

        # Close InfluxDB connection
        if self.influx_client is not None:
            logger.info("Closing InfluxDB connection...")
            try:
                self.influx_client.close()
            except Exception:  # noqa: BLE001
                logger.exception("Error while closing InfluxDB client")

        logger.info("Shutdown complete. Goodbye!")
        logger.info("=" * 70)


# ---------------------------------------------------------------------------
# Signal handling and entrypoint
# ---------------------------------------------------------------------------

# We keep a module-level reference so the signal handler can access the app.
_APP_INSTANCE: Optional[WeatherStationApp] = None


def signal_handler(signum: int, frame: object | None) -> None:
    """
    Handle termination signals (SIGINT, SIGTERM).

    Triggers graceful shutdown of the application.
    """
    logger.info("Received signal %s", signum)
    global _APP_INSTANCE
    if _APP_INSTANCE is not None:
        _APP_INSTANCE.shutdown_requested = True
    else:
        # If app is not initialized yet, exit immediately.
        sys.exit(0)


def main() -> None:
    """Main entry point for the application."""
    global _APP_INSTANCE

    app = WeatherStationApp()
    _APP_INSTANCE = app

    # Register signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        # Set up connections
        app.setup()
        # Run main loop
        app.run()

    except ConnectionError as exc:
        logger.error("Connection failed: %s", exc)
        logger.error("Make sure MQTT broker and InfluxDB are running")
        sys.exit(1)

    except Exception as exc:  # noqa: BLE001
        logger.exception("Unexpected error: %s", exc)
        sys.exit(1)

    finally:
        # Ensure cleanup happens even if setup or run fails
        if _APP_INSTANCE is not None:
            _APP_INSTANCE.shutdown()


if __name__ == "__main__":
    main()

